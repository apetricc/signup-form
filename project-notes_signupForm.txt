made our boiler plate react app (in the current dir.) with: 
npx create-react-app signup-form

that gives us the basic files, App.js is rendered by index.js
App.test.js is the tester file for App.js 
--that's the standard naming convention for test files; 

if we look in App.test.js, we can see that it's already using some testing libraries by default
and has already imported them for us, courtesy of "npx create-react-app": 
import { render, screen } from '@testing-library/react';

and we can see in package.json: 
"dependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    [removed for brevity]...
    ...
  },

--In fact, we can already run a testing command since there is a test in App.test.js: 
npm run test

which looks at our package.json file "scripts" property: 
"scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }, ...

I think this should work, but I'm getting errors, maybe need to restart vsCode.
stack overflow told me to install specific version of jest typeahead and that fixed it:
npm i -D --exact jest-watch-typeahead@0.6.5

then I can run: 
npm run test

There was one test in there by default, and that test passes; 
________________________________________________________

@24.26 -- RTL philosophy
________________________________________________________

always test how the software is meant to be used, 
not how it's implemented; 

so we'll start writing some tests, starting with our assumptions of 
how the app should work for the users: 

--> we expect the user to be able to type (input) into the text fields.


@28.30ish  

What's in a test? We have 'test' keyword/method with 2 params: 
1. a string describing the test -- this is easy, describe the test; 
2. a callback function.
    the callback function will contain all the logic of our test/tests, and usually these 3 steps
    for testing react stuff:
    1. render a component, and we're passing in App from our App component...from our application.
        This will render only that component and its children into our 'virtual DOM' (no parents)


test('describe what the test is testing', () => {
    a callback function with these 3 steps: 
    1. render something to virtual DOM so we can test it
});

the actual test and some inline notes: 
test('renders learn react link', () => {
    //1. rendering the component we want to test
  render(<App />);

  //2. 'finding the elements'; Find a specific element within the component we're testing; 
  // we're using "screen.getByText()" with a regular expression inside --> /learn react/i
  const linkElement = screen.getByText(/learn react/i);

  //3. 'An assertion' PASS/FAIL; We're expecting this anchor tag to be in the document 
  expect(linkElement).toBeInTheDocument();
});

@33 min
we can run our tests again with "npm run test"
- now we'll get 2 tests passing b/c we added the other empty test; 
- it will only fail if an error gets thrown, so an empty test will always pass; 

@33.38  if we comment out the anchor tag our test will fail; (it's the "<a> </a>" tag)
note that the error we get sort of hints at you what element is missing, the anchor tag in this case; 

@34.54 - make our 'first test'
We wanted to test if users can type into the text input box, but we will start even easier
with just testing if the box is empty in the first place; 

@38  https://testing-library.com/docs/queries/about/
--> looking at RTL docs, we want to use one of the query calls to query a single element; 

@38.20 looking at table describing the different single element query options; 
__________
getBy() --> throws error if it doesn't find the element, if it finds 1 element it returns it,
if it finds multiple--error, cannot use async/await
__________
queryBy() -->  if we want to test for the lack of an element, we'd want to use 'queryBy()' instead of 
getBy() b/c queryBy() returns 'null' if it gets 0 matches. Otherwise it is the same as getBy()
__________
findBy() --> just like getBy(), except we can use it with elements that render asynchronously (that use async/await)

-----------------
@41min:
in the docs, it says "getBy..." 
so what does the "..." mean??
It means we can put different stuff there, which are listed in "Queries Accessible to Everyone" section;

These are all the things we can use with either
getBy, queryBy, or findBy

so it says "getByRole" but we can also "queryByRole" or "findByRole" for example; 
the list: 
1. getByRole            ||  queryByRole             ||  findByRole
2. getByLabelText       ||  queryByLabelText        ||  findByLabelText
3. getByPlaceholderText ||  queryByPlaceholderText  ||  findByPlaceholderText
4. getByText            ||  queryByText             ||  findByText
5. getByDisplayValue    ||  queryByDisplayValue     ||  findByDisplayValue
6. getByAltText         ||  queryByAltText          ||  findByAltText
7. getByTitle           ||  queryByTitle            ||  findByTitle
8. getByTestId          ||  queryByTestId           ||  findByTestId

so which one do we use??!  First of all, note that these are in order of priority, 
so we should use 'Role' first, then 'LabelText', and so on; 
It says 'TestId' is the 'last resort', but we are using that a lot in production for whatever reason; 

--------
back to our first test: 

test('inputs should be empty intially', () => {
  //render the component we want to test in our 'virtual DOM'
  render(<App />)
  // next step, find the input elements we want to test (query for them)--how do we do that ..?  see the RTL 'query' docs
  const emailInputElement = screen.getByRole("textbox");
});

This test will now fail b/c we don't have anything being rendered in our App.js that has a textbox,
∴  there's no way it can find an element with a role of "textbox"
If we look at the docs for "getBy()", we see that it throws error if it doesn't find the thing;
If an error gets thrown in a test block, that causes the test to fail.

Now we go for the assertion.  We expect the input element to be completely empty; 
expect(emailInputElement.value).toBe("");

@47.58  -- we're following TDD principles, so wrote our test first, 
now we want to write the code that will make our test pass;

for styling purposes only (nothing to do with testing), 
we are going to use 'Bootstrap' by adding this to our public/index.html: 
<!-- CSS only -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-iYQeCzEYFbKjA/T2uDLTpkwGzCiq6soy8tYaI1GyVh/UjpbCx/TYkiZhlZB6+fzT" crossorigin="anonymous">

now we can add the elements in App.js to make our test pass;

@51.10 -- our tests now pass with the minimum amount of code needed to pass the tests we wrote.
I don't quite understand the relationship of our test to the stuff in our App.js yet;
is the test simply looking for any element that can hold text anywhere on the screen with this?: 
const emailInputElement = screen.getByRole("textbox");

after some digging I can see that we have a few things going on here; 
when we say `htmlFor="email"` that is a thing that automatcially knows to look for an email format string; 
We also have `<input type="email" ...` which is a similar sort of thing for email validation;
That means it knows it should be a text input, and there should be an "@" symbol etc.

@51.30-...
He mentions that if we wanted to make this a password input field, we couldn't just change the input type to:
 `input="password"`
and expect our test to pass, b/c 'password' input type doesn't count as a 'textbox' apparently; 
furthermore, 'password' (input type) has no implicit role;  
∴ we have to give any password field we want to test a label and an id like: 
<label for="password-field">Password</label>
<input id="password-field" name="password" type="password" />

clearly there's a lot to learn about html/JS and labels/input boxes 

Why our first test worked--
we had the 'label' --> `htmlFor="email"` 
we had the 'id' within the 'input' --> `<input ... id="email" .../>`

So to test the password field we need another div that has a
password input type & a label, & then we can get that input type by its label...?

@55
writing test for password field, utilize regex for this; 
then we run the usual: 
npm run test

of course it will fail b/c we haven't added a field for password yet, 
so we'll go over to our App.js file and copy the div we created already
as a boilerplate 
Then we update the "htmlFor" --> htmlFor="password"
and the input property values: 
type="password"
id="password"
name="password"

and then our tests will pass now that it can find somehting labeled as /password/i
@57.20
set up test and code for 'confirm password' input field; 

copy the 'password' div and update to 'Confirm Password', leave the input 'type' as password, 
but update the htmlFor, id, and name to 'confirm-password'

The test now fails with this error: 
"TestingLibraryElementError: Found multiple elements with the text of: /password/i"

So the regex is the issue I think;
ALso, when using 'getBy..' testing method, if it finds multiple elements that match, it throws an error, 
so this is the correct behavior;
We can update the first on to look for the string "Password" explicitly, and this would solve our issue;

@1.00.50 moving on to more complicated tests now that we've got our tests to confirm empty starting state;

next we want to test that we can give input for the text input fields that we have now; 
see what we have with: 
npm run start             and see what we have at localhost:3000
We have an email field, a password field, and a confirm password field; 
∴ we need a new test block to test this completely different thing; 

  we want to simulate a browser interaction with our test,
  we can do this using @testing-library/user-event
see: 
https://testing-library.com/docs/ecosystem-user-event/#typeelement-text-options

We want to use 'type' from documentation: 
type(element, text, [options])
Writes text inside an <input> or a <textarea>.

We need to import to use: import userEvent from '@testing-library/user-event'

set up our test, but we will be implementing 2-way binding to our input element;
we'll be storing the input value inside our 'state' & then the value of the input is also 
going to be our state ? (not sure I understand this part)
update a React 'state' when receiving input from user basically, I think.

When we update a specific value, we also update the state. Easy. 
@1.06.24-- test failing with static state of ""







  ∴   ↓   →   ←   ↔    ▲    ▼    ►    ◄ 







